// Silicon Creations Verilog Library File
// Product: testbench_block_instantiations
// Generated by: jlumish
// Date:  Mon May  4 13:49:26 EDT 2015
// Copyright 2015, Silicon Creations Inc.

`timescale 1ps / 1fs


// *
// * Schematic name: prbscheck_parallel_lsbfirst_tb
// *
module prbscheck_parallel_lsbfirst_tb(
        clk, 
        resetn,
        in, 
        error
        );

	// LSB --> MSB included
	// nbits must be greater than poly2
	parameter nbits = 10;
	parameter poly2 = 7; 
	parameter poly1 = 1; 
	
	input clk;
	input resetn;
	input [nbits-1:0] in; 
	output error;
	
	wire [nbits-1:0] in_msb; 
	reverse_bus #(.nbits(nbits)) Xreverse_bus (.in(in), .out(in_msb)); 
	prbscheck_parallel #(.nbits(nbits),.poly1(poly1),.poly2(poly2)) Xprbscheck_parallel (.clk(clk), .resetn(resetn), .in(in_msb), .error(error));
        
	
endmodule
// *
// * Schematic name: prbsgen_serial_ddr
// *
module prbsgen_serial_ddr (clk, out, insert_error);
	input clk;
	input insert_error;
	output out;
	
	parameter poly1 = 1;
	parameter poly2 = 7; 

	wire clk;
	wire reset;
	wire out;
	reg[poly2-1:0] c;
	assign out = c[poly2-1]^insert_error;

initial
	c = {poly2{1'b1}}; 


// DDR
always @(clk)
	c <= { c[poly1]^c[0], c[poly2-1:1] };  //2^31-1
endmodule
// *
// * Schematic name: prbsgen_parallel_lsbfirst_tb
// *
module prbsgen_parallel_lsbfirst_tb(
    clk, 
    resetn,
    clear,
    out 
    );

	// MSB --> LSB included
	// nbits must be greater than poly2 
	parameter nbits = 10;
	parameter poly2 = 7; 
	parameter poly1 = 1;
	
	input clk;
	input resetn;
	input clear; 
	output [nbits-1:0] out; 
	
	wire [nbits-1:0] out_msb; 
	prbsgen_parallel #(.nbits(nbits), .poly1(poly1), .poly2(poly2)) Xprbsgen_parallel (.clk(clk), .resetn(resetn), .clear(clear), .out(out_msb)); 
	reverse_bus #(.nbits(nbits)) Xreverse_bus (.in(out_msb), .out(out)); 


endmodule
// *
// * Schematic name: mini_delay_bidir
// *
module mini_delay_bidir(delay, direction, left, leftB, right, rightB, enable);

input direction; // 1 = left -> right
		// 0 = right -> left

inout left;
inout leftB;
inout right; 
inout rightB;

input enable; 	// 1'b1 --> delay
		// 1'b0 --> no delay

input [31:0] delay; // Updating so that delay is instead 1000ths of a UI
// Treat both as inputs
reg leftdel;
reg rightdel; 

real delay_int;
initial begin
	delay_int = 0;
end
always @(*) begin
	delay_int = delay+0.001; 
end

always @(right) begin
	if (enable) #(delay_int) rightdel= right;
	else rightdel = right;
end
always @(left) begin
	if (enable) #(delay_int) leftdel = left;
	else leftdel = left; 
end
initial begin
	rightdel = 0;
	leftdel = 0; 
end

assign left = direction 	? 1'bz 		: rightdel; 
assign leftB = direction 	? 1'bz 		: ~rightdel; 
assign right = direction 	? leftdel	: 1'bz; 
assign rightB = direction 	? ~leftdel 	: 1'bz; 


endmodule
// *
// * Schematic name: reverse_bus
// *
module reverse_bus (
        in, 
        out
        );

	parameter nbits = 10;

        input [nbits-1:0] in;
        output [nbits-1:0] out;

        reg [nbits-1:0] out;

	integer i;

	always @(in)
		for (i = 0 ; i < nbits; i = i + 1) begin 
			out[i] <= in[nbits-i-1];
		end

endmodule
// *
// * Schematic name: prbscheck_parallel
// *
module prbscheck_parallel(
        clk, 
        resetn,
        in, 
        error
        );

	// MSB should be serialized first
	// nbits must be greater than poly2
	parameter nbits = 10;
	parameter poly2 = 7; 
	parameter poly1 = 1; 

        input clk;
        input resetn;
        input [nbits-1:0] in;
        output error;



	reg [poly2-1:0] in_old;
	wire [nbits+poly2-1:0] in1;
	assign in1 = {in_old,in};

	
	// XOR of 1+X^poly1+X^poly2 (present bit, poly2-poly1 bits in the past and poly2 bits in the past should be 0)
	reg [nbits-1:0] error1;
	reg error0;
	reg [poly2:0] i;


    //wire error0;
    assign error = |(error1) || error0;

	

	always @(posedge clk or negedge resetn) begin
        if(!resetn) begin
            in_old <= 0; //7'b0;
            error1 <= 0;
	    error0 <= 0;
        end
        else begin
    		error0 <= ~(|(in1[poly2-1:0])); // add check for all zeros (jg) 

		for (i = 0 ; i < nbits; i = i + 1) begin //:  XOR_SECTION
		    error1[i] <= in1[i] ^ in1[i+poly2-poly1] ^ in1[i+poly2]; // implement X^poly1+X^poly2
		end
            in_old <= in[poly2-1:0];

        end
    end


endmodule
// *
// * Schematic name: prbsgen_serial_sdr
// *
module prbsgen_serial_sdr (clk, out, insert_error);
	input clk;
	input insert_error;
	output out;
	
	parameter poly1 = 1;
	parameter poly2 = 7; 

	wire clk;
	wire reset;
	wire out;
	reg[poly2-1:0] c;
	assign out = c[poly2-1]^insert_error;

initial
	c = {poly2{1'b1}}; 


// SDR
always @(posedge clk)
	c <= { c[poly1]^c[0], c[poly2-1:1] };  //2^31-1
endmodule
// *
// * Schematic name: Clock_Stats
// *
module Clock_Stats (
CLK_REF,
CLK_REF_COUNTS,
INITIALIZE,
DONE
);

input CLK_REF;
input INITIALIZE;
input [31:0] CLK_REF_COUNTS;

output DONE;
reg DONE;

real t_last,t_current,period_calc;
real t_up, t_down, t_down_prior;
real duty_cycle_mean, period_mean; 
real frequency_mean; 

reg [31:0] period_sample_number, duty_cycle_sample_number;

wire duty_cycle_done, period_done;

assign duty_cycle_done = (period_sample_number==CLK_REF_COUNTS);
assign period_done = (period_sample_number==CLK_REF_COUNTS);

initial begin
        DONE = 1'b0;
	t_last = 0;
	t_current = 0; 
	t_up = 0;
	t_down = 0;
	t_down_prior = 0; 
	period_sample_number = 32'b0;
	duty_cycle_sample_number = 32'b0; 
end

always @(posedge CLK_REF) begin	
	if (duty_cycle_done == 1'b1 && period_done == 1'b1) begin
		$display("Clock Information over %d samples",CLK_REF_COUNTS); 
		$display("Average Period: %.5f ps", period_mean);	
		$display("Average Frequency: %.5f MHz", 1e6/period_mean);	
		$display("Average Duty Cycle: %.5f%%", 100*duty_cycle_mean);	
		DONE <= 1'b1; 
	end
end

always @(posedge CLK_REF or negedge INITIALIZE) begin 
        if (INITIALIZE == 1'b0) begin
                t_current <= $time;
                t_last = t_current;
		DONE = 1'b0;
		period_mean = 0; 
        end
        else begin
		t_up <= $time; // used in duty cycle calcs 
                t_current <= $time; // used in period calcs

		// determine period
                period_calc = t_current - t_last;
		period_mean = ((period_mean * period_sample_number) + period_calc) / (period_sample_number+1);  

		// ready for next sample
                t_last <= t_current;
		period_sample_number = period_sample_number + 1; 
        end
	
end

always @(negedge CLK_REF or negedge INITIALIZE) begin
	
	if (INITIALIZE == 1'b0) begin
		period_sample_number = 0;
		duty_cycle_sample_number = 0; 
		t_down <= $time;
		t_down_prior <= t_down; 
		duty_cycle_mean = 0; 
		DONE = 1'b0; 
	end
	else begin
		// For duty cycle calculation
		t_down = $time;
		if (duty_cycle_sample_number > 0) begin
			if (t_down < t_up) begin
				// not desired, use prior t_down sample
			
			end 
			else begin
				if (t_up > 0) begin
					// use this t_down sample
					duty_cycle_mean = ((duty_cycle_sample_number-1) * duty_cycle_mean + ((t_down - t_up) / (t_down - t_down_prior))) / (duty_cycle_sample_number);  
				end
			end
		end
		duty_cycle_sample_number <= duty_cycle_sample_number + 1; 	
		t_down_prior <= t_down; 
	end
end

endmodule
// *
// * Schematic name: Pattern_Gen_Ser
// *
module Pattern_Gen_Ser (
CLK_REF,
POUTP,
POUTN,
PATTERN,
LOAD
);

parameter patternlength 	= 10; 
parameter MSBFIRST 		= 0;
parameter DDR 			= 0;

input CLK_REF;
input [patternlength-1:0] PATTERN; 

output POUTP,POUTN;
reg POUTP,POUTN;
output LOAD; 
reg LOAD; 

reg [patternlength-1:0] pattern_int;

reg [9:0] patterncount; // supports up to 1000 bits

initial begin
	patterncount = 9'b0;
	#1
	$display("Pattern Generator Started");
end

reg CurrBit; 

always @(CLK_REF) begin
	if (MSBFIRST) begin
		//Serialize MSB First
		POUTP <= pattern_int[patternlength-patterncount-1];	
		POUTN <= ~pattern_int[patternlength-patterncount-1];
	end
	else begin
		// Serialize LSB First
		POUTP <= pattern_int[patterncount];	
		POUTN <= ~pattern_int[patterncount];
	end
	patterncount = patterncount + 1; 
	if (patterncount == patternlength) begin
		patterncount = 0;
		pattern_int = PATTERN; // store pattern
		LOAD=1'b0; 
	end
	else begin
		LOAD=1'b1; 
	end
end
endmodule
// *
// * Schematic name: prbscheck_serial_sdr
// *
module prbscheck_serial_sdr (in, clk, error);

        input in;
        input clk;
        output error;

	parameter poly1=1;
	parameter poly2=7; 

        reg error;

	// save poly2-1 bits of previous word for wrap around comparison
	reg [poly2:0] in1;
	// SDR
	always @(posedge clk) begin // DDR clock
		error <= in1[0] ^ in1[poly2-poly1] ^ in1[poly2];
		in1 <= {in1[poly2-1:0],in};
	end



endmodule
// *
// * Schematic name: prbscheck_serial_ddr
// *
module prbscheck_serial_ddr (in, clk, error);

        input in;
        input clk;
        output error;

	parameter poly1=1;
	parameter poly2=7; 

        reg error;

	// save poly2-1 bits of previous word for wrap around comparison
	reg [poly2:0] in1;
	// DDR
	always @(clk) begin // DDR clock
		error <= in1[0] ^ in1[poly2-poly1] ^ in1[poly2];
		in1 <= {in1[poly2-1:0],in};
	end



endmodule
// *
// * Schematic name: Clock_to_Phase
// *
module Clock_to_Phase(refclk, expected_period, reset); 


input refclk;
input [31:0] expected_period;
input reset;

real t0,t1, period;
real phase_int; 

always @(posedge refclk or posedge reset) begin
	if (reset==1'b1) begin
		phase_int = 0; 
		t0=0;
		t1=0;
		period=0; 
	end
	else begin
		t0 <= $realtime;
		t1 <= t0;
		if (t1 > 0) begin
			period = t0 - t1; 
			phase_int = phase_int + period - expected_period; 
		end
	end
end

endmodule
// *
// * Schematic name: prbsgen_parallel
// *
module prbsgen_parallel(
    clk, 
    resetn,
    clear,
    out 
    );

	// MSB should be serialized first
	// nbits must be greater than poly2 
	parameter nbits = 10;
	parameter poly2 = 7; 
	parameter poly1 = 1;

        input resetn;
        input clear;
        input clk;
        output [nbits-1:0] out;

        reg [nbits-1:0] out;

	// self healing mode if all outputs are zero
	wire self_reset;
	assign self_reset = ~(|(out));

	
	wire [nbits+poly2-1:0] prbsin;
	assign prbsin[nbits+poly2-1:nbits] = out[poly2-1:0];
	assign prbsin[nbits-1:0] = prbsin[nbits+poly2-1:poly2] ^ prbsin[nbits+poly2-poly1-1:poly2-poly1]; 


    always @(posedge clk or negedge resetn) begin
        if(!resetn) begin
            out <= {(nbits){1'b1}};
        end
        else begin

            if (clear | self_reset) begin
			    out <= {(nbits){1'b1}};
            end
            else begin
			    out <= prbsin;
            end
        end
    end

endmodule
